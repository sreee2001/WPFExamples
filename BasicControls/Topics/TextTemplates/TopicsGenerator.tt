<#@ template language="C#" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Web.Extensions" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Web.Script.Serialization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ include file="..\..\..\Feature.Infrastructure\Core\TemplateHelpers.ttinclude" #><#

    // Read data from the JSON configuration file using a helper method
    Dictionary<string, object> topicsData = ReadJsonFile("../TopicsData.json");

    // Find The Parent Folder, Topics
    string ttFilePath = Host.TemplateFile;
    string currentFolder = Path.GetDirectoryName(ttFilePath);
    string parentFolder = Path.GetDirectoryName(currentFolder);

    // Check the existence of outputDirectory under Parent Folder (case-sensitive key)
    var outputDirectoryName = topicsData.ContainsKey("outputDirectory")
        ? topicsData["outputDirectory"].ToString()
        : "AutoGeneratedTopics";
    string outputDirectory = Path.Combine(parentFolder, outputDirectoryName);
    if (!Directory.Exists(outputDirectory))
    {
        Directory.CreateDirectory(outputDirectory);
    }

    // Get a namespace based on the template file's location
    string currentNamespaceName = GetNamespace();
    int lastDot = currentNamespaceName.LastIndexOf('.');
    string parentNnamespaceName = lastDot > 0 ? currentNamespaceName.Substring(0, lastDot) : currentNamespaceName;

    // Create a namespace name based on the parent namespace and output directory name
    string namespaceName = parentNnamespaceName + "." + outputDirectoryName;

    // Use metadataKeyClassName from JSON if present, else default
    string metadataKeyClassName = topicsData.ContainsKey("metadataKeyClassName")
        ? topicsData["metadataKeyClassName"].ToString()
        : "AddonMetadataKeys";

    const string topicsKey = "topics";
    const string topicNameKey = "topicName";
    const string subTopicNamesKey = "subTopicNames";

    // Read the topics data from the JSON file
    // Get topics array
    var topics = (topicsData[topicsKey] as System.Collections.ArrayList)
        ?.Cast<Dictionary<string, object>>()
        .ToList();
    if (topics == null)
    {
        throw new InvalidOperationException("Invalid or missing 'topics' data in the JSON file.");
    }

    // Create a metadata key for each topic name
    {
        // Generate the output file path
        string outputFilePathMetaDataKey = Path.Combine(outputDirectory, $"{metadataKeyClassName}.cs");

        // Use a StringBuilder capture T4 template output
        var sbMetaDataKey = new StringBuilder();
        var originalEnvMetaDataKey = this.GenerationEnvironment;
        this.GenerationEnvironment = sbMetaDataKey;
#>
namespace <#= namespaceName #>
{
    public partial class <#= metadataKeyClassName #>
    {
<#
        // Restore the original GenerationEnvironment and write to file
        this.GenerationEnvironment = originalEnvMetaDataKey;
        File.WriteAllText(outputFilePathMetaDataKey, sbMetaDataKey.ToString());

        foreach (var topic in topics)
        {
            string topicName = topic[topicNameKey] as string;
            string topicNameTitle = topicName + "Title";

            {
                originalEnvMetaDataKey = this.GenerationEnvironment;
                this.GenerationEnvironment = sbMetaDataKey;
#>
        public const string <#= topicNameTitle #> = "<#= ToSpacedString(topicName) #>";
<#

                // Restore the original GenerationEnvironment and write to file
                this.GenerationEnvironment = originalEnvMetaDataKey;
                File.WriteAllText(outputFilePathMetaDataKey, sbMetaDataKey.ToString());
            }
        }
        originalEnvMetaDataKey = this.GenerationEnvironment;
        this.GenerationEnvironment = sbMetaDataKey;
#>
    }
}
<#
        // Restore the original GenerationEnvironment and write to file
        this.GenerationEnvironment = originalEnvMetaDataKey;
        File.WriteAllText(outputFilePathMetaDataKey, sbMetaDataKey.ToString());
    }
    // End of metadata key generation

    // Loop through each topic
    foreach (var topic in topics)
    {
        string topicName = topic[topicNameKey] as string;
        string topicNameTitle = topicName + "Title";

        var subTopicNames = (topic[subTopicNamesKey] as System.Collections.ArrayList)
            ?.Cast<string>()
            .ToList();
        if (subTopicNames == null) continue;

        // Loop through subTopicNames
        foreach (var subTopic in subTopicNames)
        {
            // Generate the class name based on topic and subTopic names
            string className = $"{subTopic}SubTopic";

            // Generate the output file path
            string outputFilePath = Path.Combine(outputDirectory, $"{className}.cs");

            // Use a StringBuilder capture T4 template output
            var sb = new StringBuilder();
            var originalEnv = this.GenerationEnvironment;
            this.GenerationEnvironment = sb;
#>
// Auto-generated file
using Feature.Infrastructure.Core;
using Feature.Infrastructure.Interfaces;
using System.ComponentModel.Composition;

namespace <#= namespaceName #>
{
    [Export(typeof(IFeatureDemoSubTopic))]
    [ExportMetadata(MetaDataKeys.TopicName, AddonMetadataKeys.<#= topicNameTitle #>)]
    public partial class <#= className #> : IFeatureDemoSubTopic
    {
        public string Title => <#= metadataKeyClassName #>.<#= topicName #>Title;
    }
}
<#
    // Restore the original GenerationEnvironment and write to file
    this.GenerationEnvironment = originalEnv;
    File.WriteAllText(outputFilePath, sb.ToString());
#>
<#
        }
    }
#>
<#+
    // Helper method to read a JSON file and return its content as a string
    Dictionary<string, object> ReadJsonFile(string relativePath)
    {
    	// Read data from the JSON configuration file
        string jsonFilePath = Host.ResolvePath(relativePath);
        string jsonContent = File.ReadAllText(jsonFilePath);
	
        var serializer = new JavaScriptSerializer();
        var jsonData = serializer.Deserialize<Dictionary<string, object>>(jsonContent);

        return jsonData;
    }
#>